%% Solution for Project Euler prolem 008

-module(p008).
-export([solve/0]).

digits() -> [X - 48 || X <- "7316717653133062491922511967442657474235534919" ++
"49349698352031277450632623957831801698480186947885184385861560789112949495" ++
"45950173795833195285320880551112540698747158523863050715693290963295227443" ++
"04355766896648950445244523161731856403098711121722383113622298934233803081" ++
"35336276614282806444486645238749303589072962904915604407723907138105158593" ++
"07960866701724271218839987979087922749219016997208880937766572733300105336" ++
"78812202354218097512545405947522435258490771167055601360483958644670632441" ++
"57221553975369781797784617406495514929086256932197846862248283972241375657" ++
"05605749026140797296865241453510047482166370484403199890008895243450658541" ++
"22758866688116427171479924442928230863465674813919123162824586178664583591" ++
"24566529476545682848912883142607690042242190226710556263211111093705442175" ++
"06941658960408071984038509624554443629812309878799272442849091888458015616" ++
"60979191338754992005240636899125607176060588611646710940507754100225698315" ++
"5200055935729725716362695618826704282524836008232575304207529634"].

prod(L) -> lists:foldl(fun(X, Y) -> X * Y end, 1, L).

max13prod(L) -> max13prod(L, prod(lists:sublist(L, 13)), 0).
max13prod([], _, Max) -> Max;
max13prod([_|T], Curr, Max) ->
    case Curr > Max of
        true -> max13prod(T, prod(lists:sublist(T, 13)), Curr);
        false -> max13prod(T, prod(lists:sublist(T, 13)), Max)
    end.

solve() -> max13prod(digits()).
